This is a short lesson that covers a couple concepts that we’ve skipped as we focus on other things. Specifically, we’re going to discuss the static keyword that you see a lot in method signatures, and we’re going to discuss the super keyword, and how constructors work when you extend classes. This lesson should take considerably less time to complete than most previous assignments.

Static
One of the main concepts in object-oriented programming is that objects have state. By that I mean you create an object of some class, it has some variables, and cumulatively they define that object. If you have multiple objects of a given class, they probably have different values in their variables, thus differentiating them. If you were to access the variables of the objects directly, you would get a different value depending on which object you accessed. If you were to call a method of the object, you would again get a different value depending on which object you called the method for, because the variables would have different values. (E.g. if you called getLevel() on your orc, you might get a different result than if you called getLevel() on your elder dragon.)
However, there are sometimes instances where a class field or method will return the same result regardless of which object it came from. For example, consider the following method:
	public static int addNumbers(int firstNumber, int secondNumber) {
		int result = firstNumber + secondNumber;
		return result;
	}
This method happens to exist inside my DestructibleObject class from the last lesson, because that’s the last file I had open when writing this document. But you don’t need to know that; it has no bearing on the result of this method. This method is always going to return the sum of the two numbers passed to it, regardless of whether what DestructibleObject object you use to call it, and regardless of how much HP that destructible object has left. In other words, the state of the object that the method is being called from does not matter. When a method or variable fits this criterion, we use the static keyword in its signature.
	It’s not mandatory to declare these methods static – if I removed the static keyword from that method, the program would run just fine. However, the static keyword grants a special ability – you can call the method without instantiating an object of the class. In the example above, I declared this method in DestructibleObject, so I could call it as follows:
	DestructibleObject.addNumbers(11, 88);
	
Instead of using an object, we use the full class title. Because the method does not rely on the state of the object, no object is necessary. The same can be done with variables or constants. Perhaps the best example of this is the “Math” class that comes baked into the Java language. There is a static constant declared in Math called PI, so you can access the value of pi anywhere you want by calling Math.PI. And while an “addNumbers” method like above is not necessary, if it were to exist it would go in Math. In fact if you type Math.PI and then press F3 with your cursor on Math you can see some of the constants and methods that are in there. You can get a few different mathematical constants, and do operations like take the sine or cosine of a value. Math is the best example of this, and as a general rule, static methods end up being used for things that are deterministic calculations, even if they aren’t in the math class. Of course there are always exceptions. Static variables tend to be used anytime there is a program-wide constant. We use a ton of these in our robot code for our calibrations. For example:
public static final double FuelIntakePowerMagnitude = 1;
public static final double ClimberClimbPowerMagnitude = 1;
public static final double FuelPumpPowerMagnitude = .8;
I copied these lines from our robot code – they define how powerful motors should run for various applications. By making them static, we don’t have to instantiate some object to use their values.

Super
	Using inheritance creates a scenario where for a given class, there can be more than one version of a given method. One version of the method can belong to the subclass, and one can belong to its parent class, or “superclass”. In fact there could be many versions, as there could be a long chain of inherited classes, and every class in the chain could have their own version. The same situation can happen with constructors – we know that a constructor gets called whenever an object is created, but if an object of type “Player” is created, and Player objects are also “Character” objects, which constructor gets called?
	Java has default behavior to handle this situation but also gives us the ability to control what happens more directly. when a method is called for an object, it will use the method defined for the subclass. In a long chain, it will use the lowest-level class it can (that is, if the lowest-level class does not have that method defined, it will use the direct parent’s version. If the direct parent does not have that method defined, it will use the grandparent’s, etc.) This gives us the power to override parent class methods, but use them as defaults if we don’t want to override them (as you have seen and coded in recent assignments.)
	However, parent versions of methods are accessible from within a subclass by using the super keyword. The super keyword is not a variable, but it almost acts like one – if you’re in a class method (go into your Player class, inside a method, and try this) and you type “super.”, Eclipse will pull open a menu of methods that you can call, the same as if you typed the name of an object variable that has methods. From super, you can find any method defined in your parent class, and call it directly.
	The same syntax can be used for constructors, and calling superclass constructors is probably more common than calling superclass methods. Every time you create an object using the new keyword, you call a constructor. Also remember that every class has a default constructor method, even if you don’t define it. By “default”, I mean a constructor that takes no parameters. When an object of a child class get created, you call the child class’s constructor using the new keyword. Java will then automatically call the superclass’s default, or parameterless, constructor. This is referred to as calling the constructor “implicitly”. Often such a constructor does nothing so you would never notice, but you can try this out. Go into your Character class from Lesson 8 and add the following method:
 
	public Character() {
		System.out.println("Java called this constructor automatically!");
	}
	If you run your program, you will see this printout for each of the character objects you created, despite you never manually calling this constructor. Since you called your subclass constructor, and Java implicitly called the superclass constructor, that means that for subclass objects, more than one constructor is called. 
	By default Java will call the parameterless superclass constructor. But if you have custom constructors defined in your superclass and want to call a specific one, you can again use the super keyword. In this case, super is the name of a method and you give it parameters directly – for example, “super(name, hitPoints);”. If you find that you have similar constructors among your different subclasses, creating a superclass constructor and then referencing it from the subclasses can be a good strategy. The call to the superclass constructor goes in the subclass constructor, which can then do other things. For example, if all Character subclasses need to set the character’s name, you could create a Character superclass constructor to do that. But then maybe Enemy class objects need some additional work – say, initializing a “difficultyLevel” variable. In your Enemy class constructor, you would call super(name) to set the name, and then set the difficultyLevel like normal.

Exercises
1.	Create a class called “BasicOperations”. Then define and implement the following four static methods. Each class is to take two integer parameters and return and integer, except for “divide” which will take two double and return a double.
a.	add()
b.	subtract()
c.	multiply()
d.	divide()
2.	In your main method, call each of your newly created methods in a static fashion. That is, do not create an object of the class type BasicOperations – simply call the static methods.
3.	Call the following methods from the java “Math” class (e.g. double varName = Math.cos(10);) and output their values:
a.	Math.cos
b.	Math.sin
c.	Math.PI (this is a constant, not a method)
d.	Math.random() (read the description Eclipse gives to see what this method does)
4.	In Lesson 8, we created constructors for Player, NPC, and Enemy that all called the Character.setName method. Instead of using these constructors, create a single constructor in the Character class that accepts a String parameter and sets its name variable. Then, in your subclasses, call this new superclass constructor.
