For lesson 13 we‚Äôre going to do another game project, this time making a version of Power Up. This project will have a lot of similarities to the Steamworks project but a couple new things as well, to cover some of the more recent learning.
For our version of Power Up, we will track both vaults, both switches, and the scale. We will ignore climbing and autonomous for now. We will ignore cube availability on the field, but we will keep track of how many cubes are scored in the vault, and only score the first nine of them. We will ignore the use of power ups.
The game will feature a 3v3 battle between two alliances. It will be turn-based. Each turn, all six robots will take exactly one action, which the user will enter. Actions will be recorded one at a time, and after all six actions are entered, the game will ‚Äúupdate‚Äù. By update, I mean the program will check who owns each objective and assign points accordingly. The game ends after a full cycle completes, even if the user opts to skip to the end of the game early in a cycle (in other words, even after the user chooses to end the game, they must finish entering actions for the remaining robots in that cycle before the game will end.)
My implementation of this project was 630 lines long total, spread between seven files but with the majority in just two of them. Throughout this tutorial I will use abbreviations to refer to classes ‚Äì see the abbreviation guide in step 1.
The main ‚Äúnew stuff‚Äù in this project is reading in robots from a text file. The rest is review and practice. But that doesn‚Äôt mean it will be easy ‚Äì it takes a lot of review and practice to develop your skills so I expect you will have plenty of questions. Also note that some steps may end with your program having syntax errors, in particular for methods not existing yet. That‚Äôs OK. If you have a syntax error for something other than a method not existing, it‚Äôs likely a problem unless otherwise specified.
1. Let‚Äôs get started. Begin by creating your project (I called mine ‚ÄúFrcPowerUpGame‚Äù) and creating the following classes:
‚Ä¢ PowerUpAlliance (PUA)
‚Ä¢ PowerUpGame (PUG)
‚Ä¢ PowerUpGameMenu (PUGM)
‚Ä¢ PowerUpLauncher (PUL)
‚Ä¢ PowerUpRobot (PUR)
‚Ä¢ ScorableBalance (SB or Balance.) Both switches and the scale are ‚Äúscorable balances‚Äù.
‚Ä¢ Vault
2. The only purpose of PowerUpLauncher.java is to kick off your main class, PowerUpGame. Here‚Äôs a complete implementation which you can copy verbatim:
3. You may remember that there were a bunch of menu methods in the Steamworks game. In this project, we have a separate class devoted to handling the menu. This makes some information flow between the menu class and the game class necessary, but makes our game class much more focused. You can go ahead and implement PowerUpGame.start() like so. You‚Äôll get errors for ‚Äúmenu‚Äù not existing and we‚Äôll fix that next step.
4. As you can see, PowerUpGame needs to have a class field called menu. This is of type PowerUpGameMenu. Declare this as a class field for PowerUpGame.
5. We‚Äôll also need to initialize the menu object, which we want to do in PowerUpGame‚Äôs constructor. PUG doesn‚Äôt have a constructor yet, so go ahead and create one. It should not take any parameters. Once you‚Äôve created the constructor, initialize the menu class variable as a new PowerUpMenu object
6. In PowerUpGameMenu, create a welcome message method. All it needs to do is output a message that will be displayed when the program starts. Then create a runMainMenu method (detailed below.)
7. RunMainMenu is where we start to have to do some real work. Create a menu here using the same style as we did for Steamworks. Use a scanner to collect user input in the form of an integer, and a switch statement to take actions based on that input. Make sure to close your input reader after you‚Äôre done. Here‚Äôs my RMM method, which again you can copy. (I‚Äôm going easy on you‚Ä¶) You‚Äôll get an error on ‚Äúgame.‚Äù, which we‚Äôll fix next step.
8. Similar to step 4, you see that you need a class variable called game. This variable will be of type PowerUpGame. Go ahead and create this variable.
9. Easy step, but a lot of background info ‚Äì pay attention. For the last class variable we created (menu in PUG), we initialized it by creating a new object of the needed type. However, in PowerUpGameMenu, we don‚Äôt want to create a new PUG object. PUG is responsible for running and maintaining our game, and we already created one in our trivial PowerUpLauncher class. PowerUpGame is the parent of PowerUpGameMenu, so created an additional PUG inside of PUGM would be incorrect. Instead, we want to send the existing PUG variable to PUGM. This is a common concept: a parent must send its info to its child, so that the child can reference the parent. If you remember the second Steamworks project, you ran into this a lot, because individual game piece manipulators scored the points but had to reference their robot, which had to reference their alliance, which had to reference the Steamworks game itself to actually record the points being scored. So you create a chain of a parent sending its information to it‚Äôs child, so no matter how far down the chain you are, you can always reference parent data. To do this, in PowerUpGameMenu, create a constructor method that takes a single variable, a PowerUpGame object. Then initialize the PUGM class field in the constructor. You will then need to go back into PowerUpGame, where you declare your PowerUpGameMenu object, and instead of declaring it using an empty constructor, you will need to pass the parent object using the word ‚Äúthis‚Äù. The ‚Äúthis‚Äù keyword when used in this context sends the object where the this keyword is being used, to the method being called. Here, ‚Äúthis‚Äù exists inside of PowerUpGame.java, so the PowerUpGame object is what is being sent. My implementations are below and you can copy verbatim, but make sure you understand what‚Äôs going on here.
10. You can stub out PUBM.displayHighScore() and displayExitMessage() if you want. Notice that the default case is ‚ÄúrunMainMenu()‚Äù, which simply means that if the user enters an integer other than 1, 2, or 3, the menu will just run itself again.
11. Let‚Äôs work on the start new game method. The primary responsibility of this method is either initialize or reset a ton of variables. Initialize if it‚Äôs the first time the game is being run; reset if the user is playing an additional game in one sitting. Exactly which variables need to exist in this game could change depending on how you are implementing it, but let‚Äôs keep it standard. I will list the names of the variables I used in my implementation. It‚Äôs up to you to define them with the proper types, which should be clear based on their names and the classes you created earlier. All of these will need to both be declared as class fields inside of PUG, and initialized to the value they hold at the start of a game of Power Up inside of startNewGame. (Not as complicated as it sounds ‚Äì basically everything starts at zero in Power Up.) Here‚Äôs my variable list:
a. redAllianceScore
b. blueAllianceScore
c. redAllianceSwitchPoints*
d. blueAllilanceSwitchPoints*
e. redAllianceScalePoints*
f. blueAllianceScalePoints*
g. redAllianceSwitch
h. blueAllianceSwitch
i. scale
j. redAllianceVault
k. blueAllianceVault
l. elapsedGameSeconds
12. While you‚Äôre here, you‚Äôll want to declare the following additional class variables, but note that these do NOT get initialized in startNewGame, because they are either constant or not something that resets when a game does. If they are constant, make sure to declare them as final. Also, all of these can be initialized right here ‚Äì make sure to set them to the correct initial value. I used 150 for game duration seconds
a. GAME_DURATION_SECONDS ‚Äì we‚Äôre ignoring autonomous mode but I still set this to 150 seconds
b. BALANCE_CONTROL_POINTS_PER_SECOND ‚Äì the scale and switch are each worth one point per second
c. secondsPerCycle ‚Äì this is how many game seconds will elapse per cycle where the user inputs all the robot actions. 5 or 10 is a good number.
d. highScore (the highest score recorded in a session of using your program.)
13. Ok, back to PowerUpGame.startNewGame(). After you initialize all the necessary variables, add two more lines. One calling your PUGM‚Äôs displayNewGameMessage method, and one calling its runGameMenu method. You‚Äôll have to implement both of these methods. displayNewGameMessage is trivial ‚Äì it just needs to SOP something saying that you‚Äôve started a new game. runGameMenu is harder and we‚Äôll tackle it later. For now, just create a blank method for it so you don‚Äôt have syntax errors. Once you put these two calls into startNewGame, that method is done.
14. It would be nice to implement runGameMenu, but it will be hard to see it working when we don‚Äôt have robots to play with. Remember how this game is going to work: it‚Äôs going to be two robots of three alliances each, and we‚Äôre going to create those alliances and robots by parsing a text file. Let‚Äôs take care of that. In your PowerUpGame class, add two more class fields ‚Äì one for redAlliance, and one for blueAlliance.
15. In your constructor for PUG, add a method call for ‚Äúthis.initializeRobotsFromFile();‚Äù. Create a stub for this method.
16. Let‚Äôs flesh out initializeRobotsFromFile(). In this method we‚Äôre going to read a file and create six robots. We can make some assumptions about the file. First, it will contain six lines of text. Second, each line of text will contain five numbers. The last four numbers are all ‚Äúper attempt‚Äù. A probability is a number between zero and one (if you multiplied it by 100, you would have a percent chance of that action happening.) You can assume the file will be formatted correctly. There‚Äôs an example file in GitHub you can use.
a. An FRC team number (integer)
b. The probability of the robot successfully scoring in the vault
c. The probability of the robot scoring on their own switch
d. The probability of the robot scoring on their opponent‚Äôs switch
e. The probability of the robot scoring on the scale
17. Since we know there will be exactly six robots, we can declare an array of robot objects and initialize it with a size of six (as you can see, I named my array ‚Äúrobots‚Äù.) Then we‚Äôll use the following code to read the file. Since initializeRobotsFromFile has some additional work to do after the file is read, we hand off the actual reading to PUG.readFile(). Go ahead and declare that method.
18. Let‚Äôs flesh out PUG.readFile(). We‚Äôll use what‚Äôs called a BufferedReader to read text from a file. (Your file should go in the same folder than contains your ‚Äúsrc‚Äù folder ‚Äì NOT the src folder itself.) The BufferedReader.readLine(); method will read the next line of the file and return it as a String, so we can make a String variable and set it equal to this. Note that often, BufferedReaders are used with a while loop, until the file is finished. We could do this. But, we know for a fact that our file is exactly six lines, so to make it easier to address robots in our array, I used a for loop. If the file was of a different size than the for loop, this would cause an error, whereas a while loop would just run until the file is finished. We do all the file reading in this method, but hand off the creation of robot objects to a static createFromString method in PowerUpRobot which you‚Äôll write in a minute. Note how this turns each line of the file into a
robot which immediately gets stuffed into our array, which we return to PUG.readFile.
19. Now you need to create the static method createFromString inside of PowerUpRobot. It takes a string as a parameter, and returns a PowerUpRobot object. Remember the format of the string and that each number is separated by a comma. E.g. one line might read ‚Äú1188,.9,.8,.66,.5‚Äù. How to parse this string is up to you. As for turning it into a robot, please create a constructor in the PowerUpRobot class that takes five arguments ‚Äì one for each number in this string. Then once you‚Äôve parsed the numbers, you can simply call use that constructor to create and return a robot.
20. Given your successful implementation of PUR.createFromString and that I gave you PUG.readFile(), it‚Äôs time to finish PUG.initializeRobotsFromFile(). There‚Äôs actually a fair bit of work left to do here, although it‚Äôs not super complicated. The main concept here is retaining the information flow between parent and child, like we did in step nine for the PUG and PUGMenu classes.
21. You have an array with six robots, but you need to separate them into alliances. Initialize your two PowerUpAlliance objects. Red alliance gets the first three robots and blue alliance gets the second three. Make sure each alliance object can keep track of what color it is. Do this by creating a constructor in PowerUpAlliance that takes three robots and a string for alliance color. (You will need to declare all these class fields in PowerUpAlliance. Use an array to store the robots.) Then you can call your PUA constructor with the three robots and the alliance color.
22. Quick aside ‚Äì let‚Äôs discuss why we‚Äôre bothering with a PowerUpAlliance class to begin with. Why not just store all the robots in PowerUpGame? Well, you could probably get away with that, but it would get really clunky once you start trying to use the robots. For example, when a robot scores, which vault is it scoring in? In order to keep track of this, you‚Äôll either need a ton of extra methods (e.g. ‚ÄúscoreInRedVault‚Äù, ‚ÄúscoreInBlueVault‚Äù, etc), a ton of extra if statements (‚Äúif robot == red do this, else do that, etc) or most likely both. Instead we will assign them to an alliance, and then we will also assign the scoring objects to the alliance. In other words, or Alliance class will eventually have class variables for the switches, scale, and vault. Then we can simply write a ‚ÄúscoreInVault‚Äù method, that scores in the robot‚Äôs alliance‚Äôs vault. Then to keep track of score,
we simply check each alliance‚Äôs vault, switch, etc. So that‚Äôs the why. The how requires the two-way flow of information as discussed in step nine and the previous step. Each robot will need to know which alliance it is on ‚Äì not because that affects its scoring, but so that we can easily grab the alliance object, given the robot object. This concept is very important, but also kind of confusing, so if you are confused on this please let me know. That‚Äôs a lot of reading, so no coding this step üòä
23. Given all that was just discussed, let‚Äôs create two methods in PUA ‚Äì one that sets the alliance color of all the robots on the alliance (this is mostly to make our scoreboard work nicer later on), and more importantly, one that sets the alliance of each robot on the alliance. In other words, it populates the alliance variable for each robot on the alliance.
a. Both these methods are actually very easy to write. For setting the color, let‚Äôs make a method called ‚ÄúsetRobotsIsRedAlliance‚Äù that takes a boolean. We know there are only two alliance colors, and Booleans are nicer than Strings for storing data. We will convert to a string as the last step when we need to use this data, but store it as a boolean. Inside your PowerUpRobot class, you‚Äôll need to create a boolean to store this data, and a setter method to set it. Then, in setRobotsIsRedAlliance, just create a for loop (this is a good chance to use a foreach) and calls the setter.
b. Same thing for setRobotsAlliance, but instead of setting alliance color, you need to use the ‚Äúthis‚Äù keyword to set the robot‚Äôs PowerUpAlliance object.
24. Once your setters are done (and that you‚Äôre actually calling them), the second-to-last thing is to save the complete robots array to the PowerUpGame class. Create a class field for it and set the class field appropriately. This is a small amount of duplication cause in theory you could get all the robots from the red alliance and the blue alliance and that would be all the robots. However, we know we‚Äôre going to be iterating through all the robots every cycle, so we‚Äôll make our lives a little easier and just save the entire array as a PUG class field.
25. Lastly, create a method in PUA called ‚ÄúoutputAllianceString()‚Äù that just SOP‚Äôs the team numbers for the robot on the alliance, and the alliance color. Call this method for both the alliances, and your initializeRobotsFromFile() method is done!
26. We‚Äôve initialized the robots on the alliances, so let‚Äôs go ahead and finish initializing the alliances. As alluded to, an alliance contains more than just its robots. Using the classes you‚Äôve already created, flesh out the PowerUpAlliance class such that, in addition to alliance color and robots, it has all the scoring elements a PUA needs. Note that if an alliance can score on an object, it programmatically needs access to it ‚Äì even if the field doesn‚Äôt necessarily define that object as belonging to that alliance. The only exception to this is the vault ‚Äì we‚Äôll go ahead and assume no one is going to score in the opponent‚Äôs vault.
27. Now that you have class fields for scoring objects, we need to initialize those objects. Otherwise we‚Äôll get the fabled NullPointerExceptions when we try to use them. In PUA, create a setScoringObjects method that takes all the scoring objects that an alliance needs access to as parameters, and sets the PUA class fields.
28. In PUG, create a method called initializeAlliances. All it needs to do is call the setScoringObjects method for both the alliances. Remember, you already initialized all your scoring objects in PUG.startNewGame. Be careful which objects you send to which alliance, or rather in which order you send them ‚Äì if you make a mistake, both alliances might consider the same switch to be ‚Äútheir‚Äù switch!
29. Now that this method is created, add a call to it. It‚Äôs up to you to figure out where this call should go!
30. Wow, we‚Äôre almost done initializing everything, and we‚Äôre only 30 steps in! Such fast. Ok but really, if your program runs at this point and out outputAllianceString methods perform as expected, you‚Äôre in pretty good shape. Let‚Äôs implement and/or stub a couple quick methods to help us progress:
a. A getter method for the elapsed seconds in the game. Implement this fully.
b. PUG.advanceGameClock. This method simply advances the game time based on the secondsPerCycle variable. Make sure it‚Äôs not possible to advance the timer past the length of the game. Implement this method fully.
c. PUG.displayGameStatus. This will display the full status of the game at any point in time. That includes the score, the time remaining, and the number of cubes in each objective (both vaults, and both sides of each switch/scale.) Just stub this for now so you can call it where you need to, without a syntax error ‚Äì you‚Äôll implement it later.
d. PUG.updateScore. This method will check the status of the switches and scale each cycle and update the score components accordingly. (It won‚Äôt need to do anything with the vault since the vault is not a time-based objective.) Just stub this for now.
e. Stubs for the four scoring actions. Each of these will need to take a robot as a parameter, because it will pull the robot‚Äôs alliance data out the robot to find the proper scoring object:
i. Scoring in the vault
ii. Scoring on a robot‚Äôs own switch
iii. Scoring on the scale
iv. Scoring on the opponent‚Äôs scale
f. Stubs for skipping to the end of the game, and for conserving battery (robot actions.) Actually, the stub for ‚Äúconserving battery‚Äù is the entire method, since conserving battery has no other effect üòä
g. Full implementation for ‚ÄúdisplayRobotActionMenuHeader‚Äù in PUGMenu. This should be something like ‚Äúchoose action for team xxx‚Äù, and include what alliance color they are.
h. Full implementation for PUGM.displayGameMenu. This lists the actions the user can take. Score in vault, scale, etc. Include all scoring options, along with conserving battery power, and skipping to the end of the game. Make sure each action is labeled with an integer so the user knows how to select it.
i. Stub for PUGM.displayGameOverMessage.
31. We started the detour to read and initialize all the robots before tackling the ‚ÄúrunGameMenu‚Äù method in PUGM. Let‚Äôs go back to that. This is one of the trickier parts of the project and I will leave it up to you to implement. You can look back on the similar method in the Steamworks game for inspiration, and your other menu in Power Up. Basically this needs a few components:
a. A scanner to read user input, which will be an integer.
b. A while loop that runs for the duration of the game. You can check the duration of the game using the elapsed game seconds getter and the game duration.
c. It needs to call the display game status method each iteration to keep the player updated.
d. After each call of the game status, it is time to do a cycle of robot actions. Create a nested loop that iterates through each robot. This loop brings up the robot action menu and records the user selection.
e. Once the user has selected an action, run a switch statement on their input to call the proper method in PUG. (You stubbed out all these methods last step.) Set the default case to conserve battery, so if they enter anything improper it will fall back to that option.
f. After actions have been chosen for all six robots, update the game clock, and update the game score. You have stubs for these methods as well and we‚Äôll implement them later.
g. When the game duration ends, display a game over message. (Stubbed as well.)
h. At this point you should be able to stick some SOPs somewhere in any of your method stubs (or just rely on your displayGameStatus message) and you can see that your game loop is working, because you can run cycles. Even if the robot actions don‚Äôt do anything, you can see the time advancing and eventually the game will end. Now we just need to make the scoring options do things, make all the informational outputs work, and we‚Äôre done!
32. We‚Äôre going to need our scoring objects to work in order for our robots to score in them. We only have two such classes: Vault and ScorableBalance. Implement the logic for both of these classes:
a. They need to know how many cubes have been scored. If they contain cubes for both alliances (e.g. ScorableBalances), they need to know how many have been scored for each alliance.
b. They need methods to score cubes for each alliance.
c. Vault needs a get method that calculates how many vault points the alliance has earned. Each cube is worth five points, but no more than nine cubes are worth points.
d. Switch and scale need a getter that outputs the state of balance, e.g. which alliance controls that objective or if it is balanced. This method will return a string, but let‚Äôs create three static constants instead of just using plaintext: --
33. Implement your scoring methods. (Vault, switch, etc.) These all work in a very similar way:
a. Use Math.random to generate a random number between 0 and 1. Compare this to your robot‚Äôs probability of scoring for that particular action, and if the robot rolls high enough, continue.
b. Use the robot object to fetch the robot‚Äôs alliance and fetch the appropriate scoring object from the alliance.
c. Score in the fetched object. If the object can be scored on by either alliance, make sure you score for the right team.
34. Implement PUG.skipToEnd. All this has to do is set elapsed seconds to the end of the game. Note that this will allow the current cycle of robot actions to complete. (This will count as one team‚Äôs robot action, even though their robot isn‚Äôt actually doing anything. That‚Äôs fine.)
35. Now your game runs and you can score. Go back and implement your scoreboard/status methods such that you can see this happening and confirm that it‚Äôs working. You can look at step 30 for list of things you stubbed out and tackle them in any order you want, but the trickiest is probably updateScore so we‚Äôll address that one in the next step.
36. Implement updateScore. This method runs at the end of each cycle and needs to check the game state, and then apply ownership points to each alliance based on their ownership of the objectives. You have a getter method in ScorableBalance that tells you who owns each objective, but there are still a couple things to watch for:
a. Note that each cycle is more than one second long, so make sure the alliance is credited for the full time of ownership.
b. Make sure no one is credited if an objective is evenly balanced.
c. We have variables for switch and scale points even though this isn‚Äôt strictly necessary ‚Äì it‚Äôs mostly for keeping stats although we won‚Äôt use them in this project (we might add on more later.) To determine the final score for the alliance, add the vault, switch, and scale points ‚Äì but don‚Äôt add the vault points into anything other than the final score!
37. Double check that your game now runs and functions properly. You may find the odd stub you still need to implement, or an occasional getter or setter you need to flesh out. If you have scoring probabilities in your file other than 1 (100% chance of score), testing might be a bit more difficult. I recommend setting your probabilities to 1 to test that all your scoring methods works as expected, and then changing them away from 1 to make sure that your probability also works.
38. We‚Äôre almost done. Implement the session high score functionality. At the end of each game, if one alliance scored higher than the current highest score since the program was started, save that score as the new high score.
39. Double-check that all your display methods are working properly, and that all your menu options work properly. Double-check that if you start a new game immediately after you finish a game, everything still works properly and the scores reset. Double-check that your high scores are maintained and update.
40. Try playing your game. I found that if the alliances are roughly even, if one gets a lead on the scale, it‚Äôs basically GG. In other words, our sim perfectly captures the eternal hopelessness that is FRC Power Up ‚Äì the game is decided very early on, and then you‚Äôre just waiting out your misery!
I hope you enjoyed this project. I know it was long. It took a lot of effort to create it and write the tutorial. Let me know what you think. If you hate it that‚Äôs fine because it‚Äôs a lot less work for me to just give you a ton of code problems instead haha.
